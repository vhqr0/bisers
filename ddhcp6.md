# 引言

扫描网络中存活的主机是资产管理与渗透测试的一个重要组成部分。IPv4看似庞
大的32位地址空间可以用Zmap、masscan等无状态扫描工具在数小时内扫描完成，
扫描一个常见的8位或16位的子网可能只要几分钟。网络管理员和安全工程师们
已经习惯于用网络扫描工具扫描出所有存活的主机，扫描这些主机开放了哪些服
务，有哪些安全隐患，然后进行安全维护或渗透测试。 在过去IPv4盛行的时代
人们从未认为探测一个网络中有多少存活的主机是一个问题。然而，对于IPv6而
言，这个任务因其庞大的地址空间而变得无比艰巨。随着IPv6的普及，寻找有效
的IPv6扫描方法变得日益重要。

关于扫描IPv6网络的研究主要有两类分支：基于机器学习的IPv6扫描方法和基于
某种网络协议的IPv6扫描方法：前者通过学习IPv6地址分配规律找到一个地址存
活率更高的可扫描的子空间，最早在Entropy/IP[ref: Entropy/IP]中被提出，
并且更有效的模型也被不断提出[ref: ...]。这种方法的优点是远程到本地的扫
描一个IPv6网络，理论上可以用IPv6公共网络中的任意一个节点扫描任意一个子
网。但缺点是需要找到一组合适的训练来集训练模型，且扫描效果并不理想；后
者利用某些网络协议收集地址信息，通常要满足某些前提条件：在要扫描的网络
中的特定位置，网络中的IPv6节点要使用或支持某些协议或者其使用的协议实现
中存在某些问题。虽然这种地址扫描方式的条件苛刻，不普遍适用，但在特定场
景下效果出色，且能获得丰富的额外信息。

基于某种网络协议的IPv6扫描方法又分为两类：被动扫描和主动扫描： 被动扫
描通过被动地嗅探网络中的流量收集地址信息，一个典型例子是基于
DAD（Duplicated Address Detact）重复地址检测机制的IPv6扫描方法。无论是
手动配置还是自动配置，一个IPv6地址生效前都要进行DAD，通过多播NS报文检
测一个地址是否被占用。该扫描方法通过嗅探DAD的NS报文来收集局域网中的链
路本地地址与全局单播地址信息。此外，嗅探mDNS报文[ref: ...]或在用SNMP管
理的网络中嗅探SNMP报文[ref: ...]也是有效的IPv6被动扫描方法；主动扫描通
过主动地发送一些报文，然后收集这些报文引发的响应报文收集地址信息，一个
典型的例子是多播ICMPv6 EchoRequest报文，然后收集响应该报文的节点的地址。
此外，查询本地域名服务器中的本地域名记录[ref: ...]也是一种有效的主动扫
描方法。

本研究尝试利用IPv6的DHCP协议：DHCPv6协议实现IPv6扫描，具体思想是针对某
些配置了小到可以扫描的地址池的DHCPv6服务器，先快速确定其地址池边界，然
后扫描其地址池。值得一提的是，快速确定DHCPv6服务器地址池的应用不仅仅是
用来帮助网络扫描，还可能有更多应用。本文提出了两种DHCPv6定界算法，且均
有实现[note: https://github.com/vhqr0/ddhcp6]。

# 相关工作

DHCPv6客户端、中继发送给服务端的报文是多播的，一个DHCPv6报文从客户端经
过多个中继到达服务端所经过的所有局域网中的所有主机都会收到收到该报文。
攻击者可以通过嗅探DHCPv6报文收集网络中的IPv6资产信息，这是一种十分有效
的被动扫描。一方面，这些DHCPv6报文中除了地址，还包含丰富的信息：DUID、
源MAC地址可以帮助攻击者跨网络追踪一台设备；Vendor Class选项可以帮助攻
击者识别目标的硬件与操作系统；另一方面，这种被动扫描相比于其它同类型的
方法更稳定：按照约定，DHCPv6客户端要在T1时间内续租地址，即活跃的IPv6节
点在T1时间内必定发送Request、Renew、Confirm中的一个报文，攻击者可以先
检查服务端声明的T1字段，然后可以期望在数小时内收集到网络中所有的IPv6资
产信息。更多可以参考Stephen等人的工作[ref: what dhcpv6 says about you]。

基于DHCPv6的被动扫描效果拔群，但也有弱点：有些DHCPv6客户端实现默认的T1
值长达数天，其它实现也支持网络管理员设置一个很大的T1值来增长网络嗅探的
周期；此外，交换机也可以使用类似DHCP Snooping的技术对DHCPv6报文作特殊
处理，不向非信任端口转发DHCPv6请求报文来避免这种隐私缺陷。因此，有必要
探索针对DHCPv6的主动扫描方法。

关于针对DHCPv6的主动扫描，Erik等人提出了一种另辟蹊径的方法[ref:
finding a needle in a haystack]。这种方法基于部分DHCPv6服务端实现未经
仔细的安全考虑便沿用DHCPv4的实现使用线性分配地址，Erik等人提出了一种针
对这种实现的二分搜索方法。在测试过常见的DHCPv6服务端实现后，我们发现，
虽然现在中国市场上常见的家用路由器实现都使用线性分配地址，但是几个主流
的商用路由器实现和主要的软件实现都使用更安全的随机分配地址。

尽管RFC3315中并未明确说明，但几乎所有的使用随机分配地址的DHCPv6服务端
实现都采用地址池机制。假设我们找到一种方法可以快速探测DHCPv6服务器的地
址池，如果这个地址池小到可以扫描（例如，32位的地址空间，和整个IPv4网络
一样），我们可以期望在可接受的时间内扫描这个地址空间。这种地址池的配置
方式并不罕见，有些网络管理员为了便于管理或划分更多子网，常把分配到的64
位子网划分为更小的网络。虽然如果DHCPv6服务器使用一个大到不可扫描的地址
池，我们又回到了原点，但是快速探测DHCPv6服务器的地址池对IPv6网络扫描仍
有一定助益。

# 基于Rebind的DHCPv6定界算法

参考RFC3315,当DHCPv6服务端收到Rebind报文时，首先在其数据库中寻找相应的
记录，若未发现，服务端应响应一个包含该地址Reply报文，并根据该地址是否
符合其地址分配策略设置该地址的有效时间。基于这种机制，我们提出一种基于
DHCPv6 Rebind的DHCPv6服务端地址池边界二分搜索算法：

```python
def delimit(l, u):
    host = (l + u) / 2
    if l >= u:
        return host
    if rebind(host):
        if find lower limit:
            return delimit(l, host - 1)
        else:
            return delimit(host + 1, u)
    else:
        if find lower limit:
            return delimit(host + 1, u)
        else:
            return delimit(l, host - 1)
```

初始参数可以通过向DHCPv6服务端申请一个地址，然后在该地址所在的64位子网
中搜索边界。不难看出，这个算法可以通过不超过128次Rebind请求，在几秒钟
的时间内完成精确地DHCPv6定界，前提是服务端实现遵循RFC3315的规范诚实地
向Rebind请求反映自己的地址池信息。

考虑到在地址池中某个地址已经被分配的情况下，我们用Rebind报文请求该地址，
DHCPv6服务端会认为这个地址不符合其地址分配策略，与处理地址池之外的地址
的方式一致，所以我们改进了该算法：缓存通过Solicit和Rebind申请到的地址，
在探测一个地址是否在服务端的地址池中时，首先检查这个地址是否在缓存中，
若失败，再用Rebind探测，若还失败，再用邻居发现协议探测这个地址是否被某
个存活的节点占用。改进后的算法考虑到已经被分配的地址，但是仍有不足：可
能有节点请求到地址后便无法被探活，或者服务端配置中显式排除掉一些地址。
这导致我们探测的地址池中存在一些漏点，但是在庞大的地址池中分散的取不超
过128个点碰撞到这些漏点的概率很低，而且可以通过多次探测避免漏点碰撞。
我们还发现，改进后的算法扫描线性分配地址的DHCPv6服务端实现同样有效，因
为用Rebind向这些服务端请求任何地址都不符合其规范，最终会通过邻居发现协
议探活，回退到了Erik等人提出的DeHCP算法。

```python
def delimit(l, u):
    host = (l + u) / 2
    if l >= u:
        return host
    if cached(host) or rebind(host) or nd(host):
        if find lower limit:
            return delimit(l, host - 1)
        else:
            return delimit(host + 1, u)
    else:
        if find lower limit:
            return delimit(host + 1, u)
        else:
            return delimit(l, host - 1)
```

我们在几个常见的DHCPv6服务端实现上对该算法进行测试，首先观察各实现如何
处理Rebind报文，然后再尝试用该算法定界，最终发现仅在ISC DHCP Server中
有效果，在TP-Link等使用线性分配地址的家用路由器实现中也有类似于DeHCP的
效果。

虽然在理论上很完美，但是实际测试时发现只有一个常见的DHCPv6服务端实现：
ISC DHCP Server，类UNIX系统中著名的dhcpd，存在这个问题，其它实现都避免
了在响应Rebind报文时泄露地址池信息。因此，我们又提出了另一种不那么完美
与高效但是普遍有效的算法。

# 基于Solicit的DHCPv6定界算法

我们提出了一种基于DHCPv6 Solicit的DHCPv6定界方法，通过不断发起Solicit
请求记录请求到的地址的最小值与最大值，把这两个值当作边界。

```python
def delimit(l, u, n):
    l = u = solicit()
    for _ in range(n):
        a = solicit()
        if a < l:
            l = a
        if a > u:
            u = a
    return l, u
```

这是一个很简单的算法，但难以评估其有效性。首先，DHCPv6服务端实现使用的
‘随机’分配地址是怎样的随机？我们假设这种‘随机’是在统计学上随机的，
因为一旦服务端使用某种特征明显的随机地址生成方式，例如符合正态分布，尽
管我们得到的伪地址池更小，但分配的地址也向地址池的中点集中，很难认为这
种方式可以比在统计学上随机地生成地址地方法更好地抵抗该算法，而且还可能
引入安全隐患：攻击者可以更准确地预测服务端分配的地址。

以服务端在统计学上随机地生成地址，且请求次数n远小于地址池地大小为前提，
我们把如何评估该算法归化为以下数学问题：

给定区间[a,b]，在该区间中随机生成n个数，取其中的最小值和最大值a',b'，
求期望E(b'-a')。

这是一个次序统计量的期望问题，其解为((n-1)/(n+1))x(b-a)，即随着请求次
数n的增加，伪地址池占地址池的比例为(n-1)/(n+1)趋向于1，而服务端分配的
地址在地址池中是随机的，我们可以期望在此区间中扫描到同样比例的地址。通
过计算不难验证，当请求次数为200时，伪地址池的准确率超过99%。

我们可以继续改进该算法：假设得到的伪地址池为[a',b']，可以求得a,b的期望
为a'-delta,b'+delta，其中delta=(b'-a')/(n-1)。我们可以把
[a'-delta,b'+delta]当作更准确的伪地址池。

```python
def delimit(l, u, n):
    l = u = solicit()
    for _ in range(n):
        a = solicit()
        if a < l:
            l = a
        if a > u:
            u = a
    delta = (l - u) / n
    return l - delta, u + delta
```

我们选择Cisco的商用路由器实现和ISC DHCP Server软件实现来测试该算法。我
们尝试我们的算法在两种实现不同大小的子网：16位、24位、32位中，先请求
1000个地址，再使用不同的请求次数：16、32、64、128探测地址池边界，然后
统计在该伪地址池中的地址占请求到的地址的比例作为准确率，计算伪地址池边
界与地址池边界的差与地址池大小的比值作为误差率。测试结果如下：

| 环境（地址池大小/请求次数） | 准确率 | 误差率  |
|-----------------------------|--------|---------|
| 32/16                       | 0.94   | 0.193   |
| 32/32                       | 0.99   | 0.04    |
| 32/64                       | 0.978  | 0.0326  |
| 32/128                      | 0.998  | 0.00793 |
| 24/16                       | 0.978  | 0.0716  |
| 24/32                       | 0.999  | 0.0253  |
| 24/64                       | 0.997  | 0.024   |
| 24/128                      | 1.0    | 0.0109  |
| 16/16                       | 0.985  | 0.0966  |
| 16/32                       | 0.978  | 0.0546  |
| 16/64                       | 0.986  | 0.0214  |
| 16/128                      | 0.995  | 0.00817 |

观察到当请求次数超过128次时，用该算法得到的伪地址池扫描的准确率超过99%，
且与地址池的误差低于1%。虽然与基于Rebind的DHCPv6定界算法相比得到的地址
并不精确，但该算法仍是可以在几秒内探测到一个相对准确的地址池的更通用的
算法。

# 总结及进一步工作

我们提出的两种算法，在几乎所有主流的DHCPv6服务端实现上都可以用其中至少
一种方法在几秒钟内完成准确的DHCPv6定界，但是否可能成为DHCPv6服务器的一
个弱点还要看其使用的地址池的大小，如果低于32位，则扫描这个网络并不比扫
描整个IPv4网络困难。很多DHCPv6实现推荐并默认使用64位的地址池，我们也强
烈建议网络管理员在有安全需求的场景中使用的地址池的大小不要低于48位。

需要指出的是，我们简单假设DHCPv6服务端地址生成是在统计学上随机的，关于
基于Solicit的DHCPv6定界方法对使用符合其它的概率分布模型的地址生成方式
的DHCPv6服务端实现的有效性以及可能带来的安全隐患还可以做进一步研究；此
外，关于DHCPv6定界在网络扫描之外的应用也有待研究。
